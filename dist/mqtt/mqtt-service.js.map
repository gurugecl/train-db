{"version":3,"sources":["../../mqtt/mqtt-service.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"mqtt-service.js","sourcesContent":["// import mqtt from 'mqtt';\r\n// import WebSocket from 'ws';\r\n//\r\n// export function connectToType(server: MessageServerType, typeId: number) {\r\n//     const {id} = server;\r\n//     serverMap[id] = server;\r\n//\r\n//     const client = clientMap[id];\r\n//     if (client) {\r\n//         // already connected\r\n//         subscribe(id, typeId);\r\n//     } else {\r\n//         const url = `mqtt://${server.host}:${server.port}`;\r\n//         const options = {};\r\n//         const client = mqtt.connect(url, options);\r\n//         clientMap[id] = client;\r\n//\r\n//         client.on('connect', () => {\r\n//             console.info(`MQTT server ${url} connected.`);\r\n//             mqttConnected = true;\r\n//             wsSend('MQTT connected');\r\n//             subscribe(id, typeId);\r\n//         });\r\n//\r\n//         client.on('message', handleMessage.bind(null, client));\r\n//\r\n//         client.on('close', () => {\r\n//             console.info(`MQTT server ${url} connection closed.`);\r\n//             if (mqttConnected) wsSend('MQTT closed');\r\n//             mqttConnected = false;\r\n//         });\r\n//         client.on('error', err => {\r\n//             console.error(`MQTT server ${url} error:`, err);\r\n//         });\r\n//         client.on('offline', () => {\r\n//             console.info(`MQTT server ${url} is offline.`);\r\n//         });\r\n//         client.on('reconnect', () => {\r\n//             console.info(`MQTT server ${url} reconnect started.`);\r\n//         });\r\n//     }\r\n// }\r\n//\r\n// async function handleMessage(client, topic: string, message: Buffer) {\r\n//     try {\r\n//         const type = await getTopicType(topic);\r\n//         if (!type) return;\r\n//\r\n//     }\r\n//     catch (e) {\r\n//         console.error('Server Error:', e.message);\r\n//         console.error('Error Topic:', topic);\r\n//     }\r\n//\r\n// }\r\n//\r\n// export function webSocketSetup() {\r\n//     const wsServer = new WebSocket.Server({port: 1337});\r\n//     console.info('waiting for WebSocket connection');\r\n//     wsServer.on('connection', webSocket => {\r\n//         console.info('got WebSocket connection to browser');\r\n//         ws = webSocket;\r\n//\r\n//         ws.on('close', () => {\r\n//             console.info('WebSocket connection to browser closed');\r\n//             ws = null;\r\n//         });\r\n//\r\n//         ws.on('error', error => {\r\n//             if (error.code !== 'ECONNRESET') {\r\n//                 console.error('WebSocket error:', error.code);\r\n//             }\r\n//         });\r\n//\r\n//         requestFeedback();\r\n//     });\r\n// }\r\n//\r\n// function wsSend(message: string): void {\r\n//     if (ws) ws.send(message);\r\n// }"]}